--- a/lib/packlib.c	2024-10-22 12:18:10.062994120 +0000
+++ b/lib/packlib.c	2023-04-02 21:10:26.000000000 +0000
@@ -16,127 +16,258 @@
 #ifdef HAVE_STDINT_H
 #include <stdint.h>
 #endif
-#include "portable_endian.h"
+
+#ifndef _BSD_SOURCE
+#define _BSD_SOURCE             /* See feature_test_macros(7) */
+#endif
+#include <endian.h>
+#include <byteswap.h>
 #include "packer.h"
 
 #define DEBUG 0
 
-#define STORE_ORDER_BE 1
-#define STORE_ORDER_LE 2
+/* Structures for processing "broken" 64bit dictionary files */
 
-#ifndef STORE_ORDER
-#define STORE_ORDER STORE_ORDER_LE
-#endif
+struct pi_header64
+{
+    uint64_t pih_magic;
+    uint64_t pih_numwords;
+    uint16_t pih_blocklen;
+    uint16_t pih_pad;
+};
+
+typedef struct
+{
+    void *ifp;
+    void *dfp;
+    void *wfp;
+    uint64_t flags;
+    uint64_t hwms[256];
+    struct pi_header64 header;
+    int count;
+    char data_put[NUMWORDS][MAXWORDLEN];
+    char data_get[NUMWORDS][MAXWORDLEN];
+} PWDICT64;
+
+enum{
+    en_is32,
+    en_is64
+};
+
+static int
+IheaderHostToBigEndian(char *pHeader, int nBitType)
+{
+    if (nBitType == en_is64 && __BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        struct pi_header64 *pHeader64 = (struct pi_header64*)pHeader;
+
+        pHeader64->pih_magic = bswap_64(pHeader64->pih_magic);
+        pHeader64->pih_numwords = bswap_64(pHeader64->pih_numwords);
+        pHeader64->pih_blocklen = bswap_16(pHeader64->pih_blocklen);
+        pHeader64->pih_pad = bswap_16(pHeader64->pih_pad);
 
-#if STORE_ORDER == STORE_ORDER_LE
 #if DEBUG
-#warning "Choosing LITTLE ENDIAN"
+        printf("Header64: magic %x, numwords %x, blocklen %x, pad %x\n",
+          pHeader64->pih_magic, pHeader64->pih_numwords,
+          pHeader64->pih_blocklen, pHeader64->pih_pad);
 #endif
-#define STORE_32(x) htole32(x)
-#define STORE_16(x) htole16(x)
-#define FETCH_32(x, wrong) (wrong == 'n' ? le32toh(x) : be32toh(x))
-#define FETCH_16(x, wrong) (wrong == 'n' ? le16toh(x) : be16toh(x))
-#else
+    }
+    else if (nBitType == en_is32 && __BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        struct pi_header *pHeader32 = (struct pi_header*)pHeader;
+
+        pHeader32->pih_magic = bswap_32(pHeader32->pih_magic);
+        pHeader32->pih_numwords = bswap_32(pHeader32->pih_numwords);
+        pHeader32->pih_blocklen = bswap_16(pHeader32->pih_blocklen);
+        pHeader32->pih_pad = bswap_16(pHeader32->pih_pad);
+
 #if DEBUG
-#warning "Choosing BIG ENDIAN"
+        printf("Header32: magic %x, numwords %x, blocklen %x, pad %x\n",
+          pHeader32->pih_magic, pHeader32->pih_numwords,
+          pHeader32->pih_blocklen, pHeader32->pih_pad);
 #endif
-#define STORE_32(x) htobe32(x)
-#define STORE_16(x) htobe16(x)
-#define FETCH_32(x, wrong) (wrong == 'n' ? be32toh(x) : le32toh(x))
-#define FETCH_16(x, wrong) (wrong == 'n' ? be16toh(x) : le16toh(x))
-#endif
-
-static size_t
-write_header(struct pi_header *header, void *ifp, char *wrong_endian)
-{
-    struct pi_header header_copy;
-    *wrong_endian = 'n';
-    header_copy.pih_magic = STORE_32(header->pih_magic);
-    header_copy.pih_numwords = STORE_32(header->pih_numwords);
-    header_copy.pih_blocklen = STORE_16(header->pih_blocklen);
-    header_copy.pih_pad = STORE_16(header->pih_pad);
-    return fwrite((char *) &header_copy, sizeof(header_copy), 1, ifp);
+    }
+    else if (__BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        fprintf(stderr, "Neither 32 or 64: %d\n", nBitType);
+        return (-1);
+    }
+
+    return 0;
 }
 
-static size_t
-read_header(struct pi_header *header, void *ifp, char *wrong_endian)
+static int
+IheaderBigEndianToHost(char *pHeader, int nBitType)
 {
-    size_t retval;
-    struct pi_header header_copy;
-    *wrong_endian = '?';
-    retval = fread((char *) &header_copy, sizeof(header_copy), 1, ifp);
-    if (retval) {
-        if (FETCH_32(header_copy.pih_magic, 'n') == PIH_MAGIC) {
-            *wrong_endian = 'n';
-        } else if (FETCH_32(header_copy.pih_magic, 'y') == PIH_MAGIC) {
-            *wrong_endian = 'y';
-        }
-        header->pih_magic = FETCH_32(header_copy.pih_magic, *wrong_endian);
-        header->pih_numwords = FETCH_32(header_copy.pih_numwords, *wrong_endian);
-        header->pih_blocklen = FETCH_16(header_copy.pih_blocklen, *wrong_endian);
-        header->pih_pad = FETCH_16(header_copy.pih_pad, *wrong_endian);
+    if (nBitType == en_is64 && __BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        struct pi_header64 *pHeader64 = (struct pi_header64*)pHeader;
+
+        pHeader64->pih_magic = bswap_64(pHeader64->pih_magic);
+        pHeader64->pih_numwords = bswap_64(pHeader64->pih_numwords);
+        pHeader64->pih_blocklen = bswap_16(pHeader64->pih_blocklen);
+        pHeader64->pih_pad = bswap_16(pHeader64->pih_pad);
+
+#if DEBUG
+        printf("Header64: magic %x, numwords %x, blocklen %x, pad %x\n",
+          pHeader64->pih_magic, pHeader64->pih_numwords,
+          pHeader64->pih_blocklen, pHeader64->pih_pad);
+#endif
+    }
+    else if (nBitType == en_is32 && __BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        struct pi_header *pHeader32 = (struct pi_header*)pHeader;
+
+        pHeader32->pih_magic = bswap_32(pHeader32->pih_magic);
+        pHeader32->pih_numwords = bswap_32(pHeader32->pih_numwords);
+        pHeader32->pih_blocklen = bswap_16(pHeader32->pih_blocklen);
+        pHeader32->pih_pad = bswap_16(pHeader32->pih_pad);
+
+#if DEBUG
+        printf("Header32: magic %x, numwords %x, blocklen %x, pad %x\n",
+            pHeader32->pih_magic, pHeader32->pih_numwords,
+            pHeader32->pih_blocklen, pHeader32->pih_pad);
+#endif
     }
-    return retval;
+    else if (__BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        fprintf(stderr, "Neither 32 or 64: %d\n", nBitType);
+        return (-1);
+    }
+
+    return 0;
 }
 
-static size_t
-write_hwms(uint32_t hwms[256], void* wfp)
+static int
+HwmsHostToBigEndian(char *pHwms, int nLen,int nBitType)
 {
-    uint32_t hwms_copy[256];
-    int i;
-    for (i = 0; i < 256; ++i) {
-        hwms_copy[i] = STORE_32(hwms[i]);
+    int i = 0;
+
+    if (nBitType == en_is64 && __BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        uint64_t *pHwms64 = (uint64_t*)pHwms;
+
+        for (i = 0; i < nLen / sizeof(uint64_t); i++)
+        {
+            *pHwms64 = bswap_64(*pHwms64);
+            *pHwms64++;
+        }
+
+    }
+    else if (nBitType == en_is32 && __BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        uint32_t *pHwms32 = (uint32_t*)pHwms;
+
+        for (i = 0; i < nLen / sizeof(uint32_t); i++)
+        {
+            *pHwms32 = bswap_32(*pHwms32);
+            *pHwms32++;
+        }
+
+    }
+    else if (__BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        fprintf(stderr, "Neither 32 or 64: %d\n", nBitType);
+        return (-1);
     }
-    return fwrite(&hwms_copy, sizeof(hwms_copy), 1, wfp);
+
+#if DEBUG
+    for (i = 0; i < nLen; i+=8)
+    {
+        printf("hwms%s: %02X %02X %02X %02X %02X %02X %02X %02X\n",
+            nBitType==en_is64?"64":"32", pHwms[i+0]&0xFF, pHwms[i+1]&0xFF,
+            pHwms[i+2]&0xFF, pHwms[i+3]&0xFF, pHwms[i+4]&0xFF,
+            pHwms[i+5]&0xFF, pHwms[i+6]&0xFF, pHwms[i+7]&0xFF);
+    }
+#endif
+
+    return 0;
 }
 
-static size_t
-read_hwms(uint32_t hwms[256], void* wfp, char wrong_endian)
+static int
+HwmsBigEndianToHost(char *pHwms, int nLen, int nBitType)
 {
-    size_t retval;
-    uint32_t hwms_copy[256];
-    int i;
-    retval = fread(&hwms_copy, sizeof(hwms_copy), 1, wfp);
-    if (retval) {
-        for (i = 0; i < 256; ++i) {
-            hwms[i] = FETCH_32(hwms_copy[i], wrong_endian);
+    int i = 0;
+
+    if (nBitType == en_is64 && __BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        uint64_t *pHwms64 = (uint64_t*)pHwms;
+
+        for (i = 0; i < nLen / sizeof(uint64_t); i++)
+        {
+            *pHwms64++ = bswap_64(*pHwms64);
         }
+
     }
-    return retval;
-}
+    else if (nBitType == en_is32 && __BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        uint32_t *pHwms32 = (uint32_t*)pHwms;
 
+        for (i = 0; i < nLen / sizeof(uint32_t); i++)
+        {
+            *pHwms32 = bswap_32(*pHwms32);
+            *pHwms32++;
+        }
 
-static size_t
-write_index(uint32_t index, void* ifp)
-{
-    index = STORE_32(index);
-    return fwrite(&index, sizeof(index), 1, ifp);
+    }
+    else if (__BYTE_ORDER == __LITTLE_ENDIAN)
+    {
+        fprintf(stderr, "Neither 32 or 64: %d\n", nBitType);
+        return (-1);
+    }
+
+#if DEBUG
+    for (i = 0; i < nLen; i+=8)
+    {
+        printf("hwms%s: %02X %02X %02X %02X %02X %02X %02X %02X\n",
+            nBitType==en_is64?"64":"32", pHwms[i+0]&0xFF, pHwms[i+1]&0xFF,
+            pHwms[i+2]&0xFF, pHwms[i+3]&0xFF, pHwms[i+4]&0xFF,
+            pHwms[i+5]&0xFF, pHwms[i+6]&0xFF, pHwms[i+7]&0xFF);
+    }
+#endif
+
+    return 0;
 }
 
-static size_t
-read_index(uint32_t* index, void* ifp, char wrong_endian)
+static int
+_PWIsBroken64(FILE *ifp)
 {
-    size_t retval;
-    retval = fread(index, sizeof(*index), 1, ifp);
-    if (retval) {
-        *index = FETCH_32(*index, wrong_endian);
+    PWDICT64 pdesc64;
+
+    rewind(ifp);
+    if (!fread((char *) &pdesc64.header, sizeof(pdesc64.header), 1, ifp))
+    {
+       return 0;
     }
-    return retval;
+
+    IheaderBigEndianToHost((char *) &pdesc64.header, en_is64);
+    return (pdesc64.header.pih_magic == PIH_MAGIC);
 }
 
+
 PWDICT *
-PWOpen(const char *prefix, char *mode)
-{
-    PWDICT *pdesc;
+PWOpen(prefix, mode)
+    const char *prefix;
+    char *mode;
+{
+    int use64 = 0;
+    static PWDICT pdesc;
+    static PWDICT64 pdesc64;
     char iname[STRINGSIZE];
     char dname[STRINGSIZE];
     char wname[STRINGSIZE];
+    void *dfp;
+    void *ifp;
+    void *wfp;
 
-    pdesc = malloc(sizeof(*pdesc));
-    if (pdesc == NULL)
-        return NULL;
+    if (pdesc.header.pih_magic == PIH_MAGIC)
+    {
+	fprintf(stderr, "%s: another dictionary already open\n", prefix);
+	return NULL;
+    }
 
-    memset(pdesc, '\0', sizeof(*pdesc));
+    memset(&pdesc, '\0', sizeof(pdesc));
+    memset(&pdesc64, '\0', sizeof(pdesc64));
 
     snprintf(iname, STRINGSIZE, "%s.pwi", prefix);
     snprintf(dname, STRINGSIZE, "%s.pwd", prefix);
@@ -144,287 +275,372 @@
 
     if (mode[0] == 'r')
     {
-        pdesc->flags &= ~PFOR_USEZLIB;
-        /* first try the normal db file */
-        if (!(pdesc->dfp = fopen(dname, mode)))
-        {
+		pdesc.flags &= ~PFOR_USEZLIB;
+		/* first try the normal db file */
+		if (!(pdesc.dfp = fopen(dname, mode)))
+		{
 #ifdef HAVE_ZLIB_H
-            pdesc->flags |= PFOR_USEZLIB;
-            /* try extension .gz */
-            snprintf(dname, STRINGSIZE, "%s.pwd.gz", prefix);
-            if (!(pdesc->dfp = gzopen(dname, mode)))
-            {
-                    perror(dname);
-                    free(pdesc);
-                    return NULL;
-            }
+			pdesc.flags |= PFOR_USEZLIB;
+			/* try extension .gz */
+			snprintf(dname, STRINGSIZE, "%s.pwd.gz", prefix);
+			if (!(pdesc.dfp = gzopen(dname, mode)))
+			{
+				perror(dname);
+				return NULL;
+			}
 #else
-            perror(dname);
-            free(pdesc);
-            return NULL;
+		perror(dname);
+		return NULL;
 #endif
-        }
-    }
-    else
-    {
-        pdesc->flags &= ~PFOR_USEZLIB;
-        /* write mode: use fopen */
-        if (!(pdesc->dfp = fopen(dname, mode)))
-        {
-            perror(dname);
-            free(pdesc);
-            return NULL;
-        }
-    }
+		}
+	}
+	else
+	{
+		pdesc.flags &= ~PFOR_USEZLIB;
+		/* write mode: use fopen */
+		if (!(pdesc.dfp = fopen(dname, mode)))
+		{
+			perror(dname);
+			return NULL;
+		}
+	}
 
-    if (!(pdesc->ifp = fopen(iname, mode)))
+    if (!(pdesc.ifp = fopen(iname, mode)))
     {
 #ifdef HAVE_ZLIB_H
-        if (pdesc->flags & PFOR_USEZLIB)
-            gzclose(pdesc->dfp);
-        else
+		if (pdesc.flags & PFOR_USEZLIB)
+			gzclose(pdesc.dfp);
+		else
 #endif
-            fclose(pdesc->dfp);
-        perror(iname);
-        free(pdesc);
-        return NULL;
+			fclose(pdesc.dfp);
+	perror(iname);
+	return NULL;
     }
 
-    if ((pdesc->wfp = fopen(wname, mode)))
+    if ((pdesc.wfp = fopen(wname, mode)))
     {
-        pdesc->flags |= PFOR_USEHWMS;
+	pdesc.flags |= PFOR_USEHWMS;
     }
 
+    ifp = pdesc.ifp;
+    dfp = pdesc.dfp;
+    wfp = pdesc.wfp;
+
     if (mode[0] == 'w')
     {
-        pdesc->flags |= PFOR_WRITE;
-        pdesc->header.pih_magic = PIH_MAGIC;
-        pdesc->header.pih_blocklen = NUMWORDS;
-        pdesc->header.pih_numwords = 0;
-        write_header(&pdesc->header, pdesc->ifp, &pdesc->wrong_endian);
+	pdesc.flags |= PFOR_WRITE;
+	pdesc.header.pih_magic = PIH_MAGIC;
+	pdesc.header.pih_blocklen = NUMWORDS;
+	pdesc.header.pih_numwords = 0;
+
+	struct pi_header tmpheader32;
+
+	memcpy(&tmpheader32,  &pdesc.header, sizeof(pdesc.header));
+	IheaderHostToBigEndian((char *) &tmpheader32, en_is32);
+	fwrite((char *) &tmpheader32, sizeof(tmpheader32), 1, ifp);
     } else
     {
-        pdesc->flags &= ~PFOR_WRITE;
+	pdesc.flags &= ~PFOR_WRITE;
 
-        if (!read_header(&pdesc->header, pdesc->ifp, &pdesc->wrong_endian))
-        {
-            fprintf(stderr, "%s: error reading header\n", prefix);
+	if (!fread((char *) &pdesc.header, sizeof(pdesc.header), 1, ifp))
+	{
+	    fprintf(stderr, "%s: error reading header\n", prefix);
 
-            fclose(pdesc->ifp);
+	    pdesc.header.pih_magic = 0;
+	    fclose(ifp);
 #ifdef HAVE_ZLIB_H
-            if (pdesc->flags & PFOR_USEZLIB)
-                gzclose(pdesc->dfp);
-            else
-#endif
-                fclose(pdesc->dfp);
-            if (pdesc->wfp)
+		if (pdesc.flags & PFOR_USEZLIB)
+			gzclose(dfp);
+		else
+#endif
+			fclose(dfp);
+	    if (wfp)
+	    {
+		fclose(wfp);
+	    }
+	    return NULL;
+	}
+
+        IheaderBigEndianToHost((char *) &pdesc.header, en_is32);
+        if ((pdesc.header.pih_magic == 0) || (pdesc.header.pih_numwords == 0))
+        {
+            /* uh-oh. either a broken "64-bit" file or a garbage file. */
+            rewind (ifp);
+            if (!fread((char *) &pdesc64.header, sizeof(pdesc64.header), 1, ifp))
             {
-                fclose(pdesc->wfp);
-            }
-            free(pdesc);
-            return NULL;
-        }
+                fprintf(stderr, "%s: error reading header\n", prefix);
 
-        if (pdesc->header.pih_magic != PIH_MAGIC)
-        {
-            fprintf(stderr, "%s: magic mismatch\n", prefix);
+                pdesc.header.pih_magic = 0;
+                fclose(ifp);
+#ifdef HAVE_ZLIB_H
+				if (pdesc.flags & PFOR_USEZLIB)
+					gzclose(dfp);
+				else
+#endif
+					fclose(dfp);
+		if (wfp)
+		{
+			fclose(wfp);
+		}
+                return NULL;
+            }
+            IheaderBigEndianToHost((char *) &pdesc64.header, en_is64);
+            if (pdesc64.header.pih_magic != PIH_MAGIC)
+            {
+                /* nope, not "64-bit" after all */
+                fprintf(stderr, "%s: error reading header\n", prefix);
 
-            fclose(pdesc->ifp);
+                pdesc.header.pih_magic = 0;
+                fclose(ifp);
 #ifdef HAVE_ZLIB_H
-            if (pdesc->flags & PFOR_USEZLIB)
-                gzclose(pdesc->dfp);
-            else
-#endif
-                fclose(pdesc->dfp);
+				if (pdesc.flags & PFOR_USEZLIB)
+					gzclose(dfp);
+				else
+#endif
+					fclose(dfp);
+
+		if (wfp)
+		{
+			fclose(wfp);
+		}
+                return NULL;
+            }
+            pdesc.header.pih_magic = pdesc64.header.pih_magic;
+            pdesc.header.pih_numwords = pdesc64.header.pih_numwords;
+            pdesc.header.pih_blocklen = pdesc64.header.pih_blocklen;
+            pdesc.header.pih_pad = pdesc64.header.pih_pad;
+            use64 = 1;
+        }
+
+	if (pdesc.header.pih_magic != PIH_MAGIC)
+	{
+	    fprintf(stderr, "%s: magic mismatch\n", prefix);
 
-            if (pdesc->wfp)
-            {
-                fclose(pdesc->wfp);
-            }
-            free(pdesc);
-            return NULL;
-        }
+	    pdesc.header.pih_magic = 0;
+	    fclose(ifp);
+#ifdef HAVE_ZLIB_H
+		if (pdesc.flags & PFOR_USEZLIB)
+			gzclose(dfp);
+		else
+#endif
+			fclose(dfp);
+
+	    if (wfp)
+	    {
+		fclose(wfp);
+	    }
+	    return NULL;
+	}
 
-        if (pdesc->header.pih_numwords < 1)
+        if (pdesc.header.pih_numwords < 1)
         {
             fprintf(stderr, "%s: invalid word count\n", prefix);
 
-            fclose(pdesc->ifp);
+            pdesc.header.pih_magic = 0;
+            fclose(ifp);
 #ifdef HAVE_ZLIB_H
-            if (pdesc->flags & PFOR_USEZLIB)
-                gzclose(pdesc->dfp);
-            else
-#endif
-                fclose(pdesc->dfp);
-            if (pdesc->wfp)
-            {
-                fclose(pdesc->wfp);
-            }
-            free(pdesc);
+			if (pdesc.flags & PFOR_USEZLIB)
+				gzclose(dfp);
+			else
+#endif
+				fclose(dfp);
+	    if (wfp)
+	    {
+		fclose(wfp);
+	    }
             return NULL;
         }
 
-        if (pdesc->header.pih_blocklen != NUMWORDS)
-        {
-            fprintf(stderr, "%s: size mismatch\n", prefix);
+	if (pdesc.header.pih_blocklen != NUMWORDS)
+	{
+	    fprintf(stderr, "%s: size mismatch\n", prefix);
 
-            fclose(pdesc->ifp);
+	    pdesc.header.pih_magic = 0;
+	    fclose(ifp);
 #ifdef HAVE_ZLIB_H
-            if (pdesc->flags & PFOR_USEZLIB)
-                gzclose(pdesc->dfp);
-            else
-#endif
-                fclose(pdesc->dfp);
-            if (pdesc->wfp)
-            {
-                fclose(pdesc->wfp);
-            }
-            free(pdesc);
-            return NULL;
-        }
+		if (pdesc.flags & PFOR_USEZLIB)
+			gzclose(dfp);
+		else
+#endif
+			fclose(dfp);
+		if (wfp)
+	    {
+		fclose(wfp);
+	    }
+	    return NULL;
+	}
 
-        if (pdesc->flags & PFOR_USEHWMS)
-        {
-            if (read_hwms(pdesc->hwms, pdesc->wfp, pdesc->wrong_endian) != sizeof(pdesc->hwms))
+	if (pdesc.flags & PFOR_USEHWMS)
+	{
+            int i;
+
+            if (use64)
             {
-                pdesc->flags &= ~PFOR_USEHWMS;
+                if (fread(pdesc64.hwms, 1, sizeof(pdesc64.hwms), wfp) != sizeof(pdesc64.hwms))
+                {
+                    pdesc.flags &= ~PFOR_USEHWMS;
+                }
+                HwmsBigEndianToHost((char*)pdesc64.hwms, sizeof(pdesc64.hwms), en_is64);
+                for (i = 0; i < sizeof(pdesc.hwms) / sizeof(pdesc.hwms[0]); i++)
+                {
+                    pdesc.hwms[i] = pdesc64.hwms[i];
+                }
             }
+            else if (fread(pdesc.hwms, 1, sizeof(pdesc.hwms), wfp) != sizeof(pdesc.hwms))
+	    {
+		pdesc.flags &= ~PFOR_USEHWMS;
+	    }
+	    HwmsBigEndianToHost((char*)pdesc.hwms, sizeof(pdesc.hwms), en_is32);
 #if DEBUG
-            int i;
             for (i=1; i<=0xff; i++)
             {
-                fprintf(stderr, "hwm[%02x] = %d\n", i, pdesc->hwms[i]);
+                printf("hwm[%02x] = %d\n", i, pdesc.hwms[i]);
             }
 #endif
-        }
+	}
     }
 
-    return (pdesc);
+    return (&pdesc);
 }
 
 int
-PWClose(PWDICT *pwp)
+PWClose(pwp)
+    PWDICT *pwp;
 {
     if (pwp->header.pih_magic != PIH_MAGIC)
     {
-        fprintf(stderr, "PWClose: close magic mismatch\n");
-        return (-1);
+	fprintf(stderr, "PWClose: close magic mismatch\n");
+	return (-1);
     }
 
     if (pwp->flags & PFOR_WRITE)
     {
-        pwp->flags |= PFOR_FLUSH;
-        PutPW(pwp, NULL);        /* flush last index if necess */
+	pwp->flags |= PFOR_FLUSH;
+	PutPW(pwp, NULL);	/* flush last index if necess */
 
-        if (fseek(pwp->ifp, 0L, 0))
-        {
-            fprintf(stderr, "index magic fseek failed\n");
-            free(pwp);
-            return (-1);
-        }
-
-        if (!write_header(&pwp->header, pwp->ifp, &pwp->wrong_endian))
-        {
-            fprintf(stderr, "index magic fwrite failed\n");
-            free(pwp);
-            return (-1);
-        }
-
-        if (pwp->flags & PFOR_USEHWMS)
-        {
-            int i;
-            for (i=1; i<=0xff; i++)
-            {
-                if (!pwp->hwms[i])
-                {
-                    pwp->hwms[i] = pwp->hwms[i-1];
-                }
-#if DEBUG
-                fprintf(stderr, "hwm[%02x] = %d\n", i, pwp->hwms[i]);
-#endif
-            }
-            write_hwms(pwp->hwms, pwp->wfp);
-        }
+	if (fseek(pwp->ifp, 0L, 0))
+	{
+	    fprintf(stderr, "index magic fseek failed\n");
+	    return (-1);
+	}
+
+	struct pi_header tmpheader32;
+
+	memcpy(&tmpheader32,  &pwp->header, sizeof(pwp->header));
+	IheaderHostToBigEndian((char *) &tmpheader32, en_is32);
+	if (!fwrite((char *) &tmpheader32, sizeof(tmpheader32), 1, pwp->ifp))
+	{
+	    fprintf(stderr, "index magic fwrite failed\n");
+	    return (-1);
+	}
+
+	if (pwp->flags & PFOR_USEHWMS)
+	{
+	    int i;
+	    for (i=1; i<=0xff; i++)
+	    {
+	    	if (!pwp->hwms[i])
+	    	{
+	    	    pwp->hwms[i] = pwp->hwms[i-1];
+	    	}
+#if DEBUG
+	    	printf("hwm[%02x] = %d\n", i, pwp->hwms[i]);
+#endif
+	    }
+
+	    PWDICT tmp_pwp;
+
+	    memcpy(&tmp_pwp, pwp, sizeof(PWDICT));
+	    HwmsHostToBigEndian(tmp_pwp.hwms, sizeof(tmp_pwp.hwms), en_is32);
+	    fwrite(tmp_pwp.hwms, 1, sizeof(tmp_pwp.hwms), pwp->wfp);
+	}
     }
 
     fclose(pwp->ifp);
 #ifdef HAVE_ZLIB_H
-    if (pwp->flags & PFOR_USEZLIB)
-        gzclose(pwp->dfp);
-    else
+	if (pwp->flags & PFOR_USEZLIB)
+		gzclose(pwp->dfp);
+	else
 #endif
-        fclose(pwp->dfp);
+		fclose(pwp->dfp);
     if (pwp->wfp)
     {
         fclose(pwp->wfp);
     }
 
     pwp->header.pih_magic = 0;
-    free(pwp);
 
     return (0);
 }
 
 int
-PutPW(PWDICT *pwp, char *string)
+PutPW(pwp, string)
+    PWDICT *pwp;
+    char *string;
 {
     if (!(pwp->flags & PFOR_WRITE))
     {
-        return (-1);
+	return (-1);
     }
 
     if (string)
     {
-        strncpy(pwp->data_put[pwp->count], string, MAXWORDLEN);
-        pwp->data_put[pwp->count][MAXWORDLEN - 1] = '\0';
+	strncpy(pwp->data_put[pwp->count], string, MAXWORDLEN);
+	pwp->data_put[pwp->count][MAXWORDLEN - 1] = '\0';
 
-        pwp->hwms[string[0] & 0xff]= pwp->header.pih_numwords;
+	pwp->hwms[string[0] & 0xff]= pwp->header.pih_numwords;
 
-        ++(pwp->count);
-        ++(pwp->header.pih_numwords);
+	++(pwp->count);
+	++(pwp->header.pih_numwords);
 
     } else if (!(pwp->flags & PFOR_FLUSH))
     {
-        return (-1);
+	return (-1);
     }
 
     if ((pwp->flags & PFOR_FLUSH) || !(pwp->count % NUMWORDS))
     {
-        int i;
-        register char *ostr;
-
-        write_index((uint32_t)ftell(pwp->dfp), pwp->ifp);
+	int i;
+	uint32_t datum;
+	register char *ostr;
+
+	datum = (uint32_t) ftell(pwp->dfp);
+
+	uint32_t tmpdatum = (__BYTE_ORDER == __LITTLE_ENDIAN) ? bswap_32(datum) : datum;
+	fwrite((char *) &tmpdatum, sizeof(tmpdatum), 1, pwp->ifp);
+
+	fputs(pwp->data_put[0], pwp->dfp);
+	putc(0, (FILE*) pwp->dfp);
+
+	ostr = pwp->data_put[0];
+
+	for (i = 1; i < NUMWORDS; i++)
+	{
+	    register int j;
+	    register char *nstr;
+	    nstr = pwp->data_put[i];
+
+	    if (nstr[0])
+	    {
+		for (j = 0; ostr[j] && nstr[j] && (ostr[j] == nstr[j]); j++);
+		putc(j & 0xff, (FILE*) pwp->dfp);
+		fputs(nstr + j, pwp->dfp);
+	    }
+	    putc(0, (FILE*) pwp->dfp);
 
-        fputs(pwp->data_put[0], pwp->dfp);
-        putc(0, (FILE*) pwp->dfp);
+	    ostr = nstr;
+	}
 
-        ostr = pwp->data_put[0];
-
-        for (i = 1; i < NUMWORDS; i++)
-        {
-            register int j;
-            register char *nstr;
-            nstr = pwp->data_put[i];
-
-            if (nstr[0])
-            {
-                for (j = 0; ostr[j] && nstr[j] && (ostr[j] == nstr[j]); j++);
-                putc(j & 0xff, (FILE*) pwp->dfp);
-                fputs(nstr + j, pwp->dfp);
-            }
-            putc(0, (FILE*) pwp->dfp);
-
-            ostr = nstr;
-        }
-
-        memset(pwp->data_put, '\0', sizeof(pwp->data_put));
-        pwp->count = 0;
+	memset(pwp->data_put, '\0', sizeof(pwp->data_put));
+	pwp->count = 0;
     }
     return (0);
 }
 
 char *
-GetPW(PWDICT *pwp, uint32_t number)
+GetPW(pwp, number)
+    PWDICT *pwp;
+    uint32_t number;
 {
     uint32_t datum;
     register int i;
@@ -436,60 +652,73 @@
 
     thisblock = number / NUMWORDS;
 
-#if DEBUG
-    fprintf(stderr, "seeking index at: 0x%lx\n", thisblock *sizeof(uint32_t));
-#endif
-    if (fseek(pwp->ifp, sizeof(struct pi_header) + (thisblock * sizeof(uint32_t)), 0))
-    {
-        perror("(index fseek failed)");
-        return NULL;
-    }
-
-    if (!read_index(&datum, pwp->ifp, pwp->wrong_endian))
+    if (_PWIsBroken64(pwp->ifp))
     {
-        perror("(index fread failed)");
-        return NULL;
+       uint64_t datum64;
+       if (fseek(pwp->ifp, sizeof(struct pi_header64) + (thisblock * sizeof(uint64_t)), 0))
+       {
+           perror("(index fseek failed)");
+           return NULL;
+       }
+
+       if (!fread((char *) &datum64, sizeof(datum64), 1, pwp->ifp))
+       {
+           perror("(index fread failed)");
+           return NULL;
+       }
+       datum64 = (__BYTE_ORDER == __LITTLE_ENDIAN) ? bswap_64(datum64) : datum64;
+       datum = datum64;
+    } else {
+       if (fseek(pwp->ifp, sizeof(struct pi_header) + (thisblock * sizeof(uint32_t)), 0))
+       {
+           perror("(index fseek failed)");
+           return NULL;
+       }
+
+       if (!fread((char *) &datum, sizeof(datum), 1, pwp->ifp))
+       {
+           perror("(index fread failed)");
+           return NULL;
+       }
+       datum = (__BYTE_ORDER == __LITTLE_ENDIAN) ? bswap_32(datum) : datum;
     }
-#if DEBUG
-    fprintf(stderr, "read index: 0x%x, wrong_endian = %c\n", datum, pwp->wrong_endian);
-#endif
 
-    int r = 1;
+	int r = 1;
 #ifdef HAVE_ZLIB_H
-    if (pwp->flags & PFOR_USEZLIB)
-    {
-        r = gzseek(pwp->dfp, datum, 0);
-        if (r >= 0)
-            r = 0;
-    }
-    else
+	if (pwp->flags & PFOR_USEZLIB)
+	{
+		r = gzseek(pwp->dfp, datum, 0);
+		if (r >= 0)
+			r = 0;
+	}
+	else
 #endif
-        r = fseek(pwp->dfp, datum, 0);
+		r = fseek(pwp->dfp, datum, 0);
 
 
     if (r)
     {
-        perror("(data fseek failed)");
-        return NULL;
+	perror("(data fseek failed)");
+	return NULL;
     }
-    r = 0;
+	r = 0;
 
-    memset(buffer, 0, sizeof(buffer));
+        memset(buffer, 0, sizeof(buffer));
 #ifdef HAVE_ZLIB_H
-    if (pwp->flags & PFOR_USEZLIB)
-    {
-        r = gzread(pwp->dfp, buffer, sizeof(buffer));
-        if (r < 0)
-            r = 0;
-    }
-    else
+	if (pwp->flags & PFOR_USEZLIB)
+	{
+		r = gzread(pwp->dfp, buffer, sizeof(buffer));
+		if (r < 0)
+			r = 0;
+	}
+	else
 #endif
-        r = fread(buffer, 1, sizeof(buffer), pwp->dfp);
+		r = fread(buffer, 1, sizeof(buffer), pwp->dfp);
 
     if (!r)
     {
-        perror("(data fread failed)");
-        return NULL;
+	perror("(data fread failed)");
+	return NULL;
     }
 
     bptr = buffer;
@@ -500,20 +729,22 @@
 
     for (i = 1; i < NUMWORDS; i++)
     {
-        nstr = pwp->data_get[i];
-        strcpy(nstr, ostr);
+	nstr = pwp->data_get[i];
+	strcpy(nstr, ostr);
 
-        ostr = nstr + *(bptr++);
-        while ((*(ostr++) = *(bptr++)));
+	ostr = nstr + *(bptr++);
+	while ((*(ostr++) = *(bptr++)));
 
-        ostr = nstr;
+	ostr = nstr;
     }
 
     return (pwp->data_get[number % NUMWORDS]);
 }
 
 unsigned int
-FindPW(PWDICT *pwp, char *string)
+FindPW(pwp, string)
+    PWDICT *pwp;
+    char *string;
 {
     register uint32_t lwm;
     register uint32_t hwm;
@@ -522,89 +753,89 @@
     int idx;
 
 #if DEBUG
-    fprintf(stderr, "look for (%s)\n", string);
+fprintf(stderr, "look for (%s)\n", string);
 #endif
 
     if (pwp->flags & PFOR_USEHWMS)
     {
-        idx = string[0] & 0xff;
-        lwm = idx ? pwp->hwms[idx - 1] : 0;
-        hwm = pwp->hwms[idx];
+	idx = string[0] & 0xff;
+    	lwm = idx ? pwp->hwms[idx - 1] : 0;
+    	hwm = pwp->hwms[idx];
 
 #if DEBUG
-        fprintf(stderr, "idx = %d\n", idx);
-        fprintf(stderr, "lwm = %d,  hwm = %d\n", lwm, hwm);
+	fprintf(stderr, "idx = %d\n", idx);
+	fprintf(stderr, "lwm = %d,  hwm = %d\n", lwm, hwm);
 #endif
     } else
     {
-        lwm = 0;
-        hwm = PW_WORDS(pwp) - 1;
+    	lwm = 0;
+    	hwm = PW_WORDS(pwp) - 1;
     }
 
     /* if the high water mark is lower than the low water mark, something is screwed up */
     if ( hwm < lwm )
     {
-        lwm = 0;
-        hwm = PW_WORDS(pwp) - 1;
+	lwm = 0;
+	hwm = PW_WORDS(pwp) - 1;
     }
 
 #if DEBUG
-    fprintf(stderr, "---- %u, %u ----\n", lwm, hwm);
+    fprintf(stderr, "---- %lu, %lu ----\n", lwm, hwm);
 #endif
 
     for (;;)
     {
-        int cmp;
+	int cmp;
 
-        middle = lwm + ((hwm - lwm + 1) / 2);
+	middle = lwm + ((hwm - lwm + 1) / 2);
 
 #if DEBUG
-        fprintf(stderr, "lwm = %u,  middle = %u,  hwm = %u\n", lwm, middle, hwm);
+	fprintf(stderr, "lwm = %lu,  middle = %lu,  hwm = %lu\n", lwm, middle, hwm);
 #endif
 
-        this = GetPW(pwp, middle);
-        if ( ! this )
-        {
+	this = GetPW(pwp, middle);
+	if ( ! this )
+	{
 #if DEBUG
-            fprintf(stderr, "getpw returned null, returning null in FindPW\n");
+		fprintf(stderr, "getpw returned null, returning null in FindPW\n");
 #endif
-            return(PW_WORDS(pwp));
-        }
-        else
-        {
+		return(PW_WORDS(pwp));
+	}
+	else
+	{
 #if DEBUG
-            fprintf(stderr, "comparing %s against found %s\n", string, this);
+		fprintf(stderr, "comparing %s against found %s\n", string, this);
 #endif
-        }
+	}
 
-        cmp = strcmp(string, this);
-        if (cmp == 0)
-        {
-            return(middle);
+	cmp = strcmp(string, this);
+	if (cmp == 0)
+	{
+	    return(middle);
         }
 
-        if (cmp < 0)
-        {
-            if (middle == lwm)
-            {
-#if DEBUG
-                fprintf(stderr, "at terminal subdivision from right, stopping search\n");
+	if (cmp < 0)
+	{
+	    if (middle == lwm)
+	    {
+#if DEBUG 
+		fprintf(stderr, "at terminal subdivision from right, stopping search\n");
 #endif
-                break;
-            }
-            hwm = middle - 1;
-        }
-        else if (cmp > 0)
-        {
-            if (middle == hwm)
-            {
-#if DEBUG
-                fprintf(stderr, "at terminal subdivision from left, stopping search\n");
+		break;
+	    }
+	    hwm = middle - 1;
+	} 
+	else if (cmp > 0)
+	{
+	    if (middle == hwm)
+	    {
+#if DEBUG 
+		fprintf(stderr, "at terminal subdivision from left, stopping search\n");
 #endif
-                break;
-            }
-            lwm = middle + 1;
-        }
+		break;
+	    }
+	    lwm = middle + 1;
+	} 
     }
 
     return (PW_WORDS(pwp));
